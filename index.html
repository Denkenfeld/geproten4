<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chroma-Cham√§leon: Tipp-Spa√ü</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Varela+Round&display=swap');

        body { margin: 0; overflow: hidden; background: #222; font-family: 'Varela Round', sans-serif; user-select: none; }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Header */
        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
        }
        h1 { font-family: 'Fredoka One'; color: #ffeb3b; margin: 0; font-size: 2rem; letter-spacing: 1px; }
        .score { font-size: 1.5rem; color: white; background: rgba(255,255,255,0.2); padding: 5px 20px; border-radius: 20px; backdrop-filter: blur(4px); }

        /* Keyboard Display */
        #keyboard-hud {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 20px; backdrop-filter: blur(10px);
        }
        .key-box {
            width: 50px; height: 50px; background: #fff; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Fredoka One'; font-size: 1.5rem; color: #333;
            box-shadow: 0 4px 0 #ccc; transition: transform 0.1s;
        }
        .key-box.active { transform: translateY(4px); box-shadow: 0 0 0 #ccc; background: #ffeb3b; }
        
        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; pointer-events: auto; color: white;
        }
        .screen.hidden { opacity: 0; pointer-events: none; }
        
        button {
            margin-top: 20px; padding: 15px 40px; border: none; border-radius: 50px;
            font-family: 'Fredoka One'; font-size: 1.5rem; cursor: pointer;
            background: #ffeb3b; color: #d35400; box-shadow: 0 6px 0 #e67e22;
            transition: transform 0.1s;
        }
        button:active { transform: translateY(6px); box-shadow: 0 0 0 #e67e22; }

        /* Floating Target Feedback */
        .pop-text {
            position: absolute; font-family: 'Fredoka One'; font-size: 3rem; color: #fff;
            pointer-events: none; animation: popUp 1s forwards; text-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        @keyframes popUp { 
            0% { transform: scale(0.5) translateY(0); opacity: 0; }
            20% { transform: scale(1.2) translateY(-20px); opacity: 1; }
            100% { transform: scale(1) translateY(-100px); opacity: 0; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui">
        <div class="hud-top">
            <h1>ü¶é Chroma-Cham√§leon</h1>
            <div class="score" id="score-el">‚≠ê 0</div>
        </div>
        <div id="keyboard-hud"></div>
    </div>

    <div id="start-screen" class="screen">
        <h1 style="font-size: 4rem; margin-bottom: 0;">Hunger!</h1>
        <p style="font-size: 1.5rem; max-width: 600px; text-align: center;">
            Camillo das Cham√§leon hat Hunger auf Buchstaben-K√§fer!<br>
            Tippe den Buchstaben, damit er ihn schnappt.
        </p>
        <button id="btn-start">Spiel Starten ‚ñ∂</button>
    </div>

    <div id="end-screen" class="screen hidden">
        <h1 style="font-size: 3rem;">Satt & Gl√ºcklich!</h1>
        <div style="font-size: 6rem;">üí©‚ú®</div>
        <p>(Ups, ein Regenbogen-H√§ufchen!)</p>
        <button id="btn-next">N√§chstes Level ‚ñ∂</button>
    </div>

<script>
/** * CONFIGURATION 
 */
const LEVELS = [
    { keys: "fj", name: "F & J" },
    { keys: "dk", name: "D & K" },
    { keys: "sl", name: "S & L" },
    { keys: "a√∂", name: "A & √ñ" },
    { keys: "ruei", name: "R, U, E, I" },
    { keys: "qwertz", name: "Obere Reihe" }
];

const COLORS = {
    skin: 0x00b894,
    belly: 0x55efc4,
    eye: 0xffffff,
    pupil: 0x2d3436,
    tongue: 0xff7675,
    bg_top: 0x81ecec,
    bg_bot: 0x74b9ff
};

let STATE = {
    levelIdx: 0,
    score: 0,
    isPlaying: false,
    bugs: [], // The flying letters
    activeBug: null // The one currently highlighted
};

/**
 * AUDIO (Tone.js)
 */
let synth, tongueSynth, chewSynth;

async function initAudio() {
    await Tone.start();
    // Happy chimes
    synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
    }).toDestination();
    synth.volume.value = -10;

    // Slurp sound
    tongueSynth = new Tone.MembraneSynth({
        pitchDecay: 0.05, octaves: 4, oscillator: { type: "sine" }
    }).toDestination();

    // Funny crunch
    chewSynth = new Tone.NoiseSynth({
        noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 }
    }).toDestination();
}

function playSlurp() {
    tongueSynth.triggerAttackRelease("C2", "8n");
    setTimeout(() => chewSynth.triggerAttackRelease("16n"), 200);
}
function playWin() {
    const now = Tone.now();
    ["C4", "E4", "G4", "C5"].forEach((n, i) => synth.triggerAttackRelease(n, "8n", now + i*0.1));
}
function playPoop() {
    tongueSynth.triggerAttackRelease("A1", "4n");
}

/**
 * THREE.JS SETUP
 */
let scene, camera, renderer, clock;
let chameleonGroup, headGroup, eyeL, eyeR, pupilL, pupilR, jaw, tongueMesh;
let targetLookAt = new THREE.Vector3(0,0,5); // Eyes follow this
let tongueActive = false;
let tongueTargetPos = new THREE.Vector3();

function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg_top);
    scene.fog = new THREE.Fog(COLORS.bg_top, 10, 50);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 1, 8);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Environment (Island)
    createEnvironment();
    
    // Character
    createChameleon();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
}

function createEnvironment() {
    // Floating Island
    const geo = new THREE.CylinderGeometry(6, 4, 2, 7);
    const mat = new THREE.MeshStandardMaterial({ color: 0x6ab04c, flatShading: true });
    const island = new THREE.Mesh(geo, mat);
    island.position.y = -2;
    island.receiveShadow = true;
    scene.add(island);

    // Some low poly rocks/grass
    const rockGeo = new THREE.DodecahedronGeometry(0.5);
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, flatShading: true });
    for(let i=0; i<5; i++) {
        const rock = new THREE.Mesh(rockGeo, rockMat);
        rock.position.set((Math.random()-0.5)*6, -1, (Math.random()-0.5)*4);
        rock.castShadow = true;
        scene.add(rock);
    }
}

/**
 * CHARACTER RIGGING (Procedural Geometry)
 */
function createChameleon() {
    chameleonGroup = new THREE.Group();
    
    const skinMat = new THREE.MeshStandardMaterial({ color: COLORS.skin, roughness: 0.6, flatShading: true });
    const bellyMat = new THREE.MeshStandardMaterial({ color: COLORS.belly, roughness: 0.6, flatShading: true });

    // BODY
    const bodyGeo = new THREE.IcosahedronGeometry(1.2, 0); // Low poly look
    bodyGeo.scale(1, 0.8, 1.5);
    const body = new THREE.Mesh(bodyGeo, skinMat);
    body.castShadow = true;
    chameleonGroup.add(body);

    // TAIL (Curled cylinder)
    // Simplified as a torus segment
    const tailGeo = new THREE.TorusGeometry(0.8, 0.2, 8, 20, 4);
    const tail = new THREE.Mesh(tailGeo, skinMat);
    tail.position.set(0, -0.2, -1.5);
    tail.rotation.x = Math.PI/2;
    tail.rotation.z = 2;
    body.add(tail);

    // HEAD GROUP (Pivot at neck)
    headGroup = new THREE.Group();
    headGroup.position.set(0, 0.5, 1);
    chameleonGroup.add(headGroup);

    // HEAD MESH
    const headGeo = new THREE.ConeGeometry(0.9, 1.5, 6);
    headGeo.rotateX(-Math.PI/2); // Point forward
    const head = new THREE.Mesh(headGeo, skinMat);
    head.castShadow = true;
    headGroup.add(head);

    // EYES (The Pixar Part - Independent Movement)
    const eyeGeo = new THREE.SphereGeometry(0.35, 16, 16);
    const pupilGeo = new THREE.SphereGeometry(0.12, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({ color: COLORS.eye });
    const pupilMat = new THREE.MeshBasicMaterial({ color: COLORS.pupil });

    function createEye(x) {
        const group = new THREE.Group();
        group.position.set(x, 0.3, 0.4); // On top of head
        
        // Eye housing (Skin colored eyelid bump)
        const bump = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), skinMat);
        headGroup.add(group); // Add group to head
        group.add(bump);

        // White ball
        const ball = new THREE.Mesh(eyeGeo, eyeMat);
        ball.position.z = 0.1;
        group.add(ball);

        // Pupil (Child of ball so it rotates with it)
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        pupil.position.z = 0.3;
        ball.add(pupil);

        return { group, ball }; // Return ball to control rotation
    }

    const left = createEye(-0.5);
    const right = createEye(0.5);
    eyeL = left.ball;
    eyeR = right.ball;

    // JAW (For opening mouth)
    jaw = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 1), bellyMat);
    jaw.position.set(0, -0.4, 0.2);
    jaw.geometry.translate(0, 0, 0.5); // Pivot at back
    headGroup.add(jaw);

    // TONGUE (Hidden initially)
    // We use a cylinder that we stretch
    const tongueGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
    tongueGeo.rotateX(-Math.PI/2); // Point forward Z
    tongueGeo.translate(0, 0, 0.5); // Pivot at start
    tongueMesh = new THREE.Mesh(tongueGeo, new THREE.MeshStandardMaterial({ color: COLORS.tongue }));
    tongueMesh.visible = false;
    headGroup.add(tongueMesh);

    scene.add(chameleonGroup);
}

/**
 * GAMEPLAY LOGIC: BUGS & TYPING
 */
function createBug(char) {
    // A bug is a 3D Sprite with a letter
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // Draw Bug Wings
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    ctx.beginPath(); ctx.ellipse(64, 64, 60, 30, 0, 0, Math.PI*2); ctx.fill();
    
    // Draw Bug Body
    ctx.fillStyle = "#FF5722";
    ctx.beginPath(); ctx.arc(64, 64, 25, 0, Math.PI*2); ctx.fill();

    // Draw Letter
    ctx.fillStyle = "white";
    ctx.font = "bold 40px Arial";
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(char.toUpperCase(), 64, 64);

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(1.5, 1.5, 1);
    
    // Random position in a semi-circle in front of player
    const angle = Math.PI/4 + Math.random() * Math.PI/2; // Front arc
    const dist = 3 + Math.random() * 2;
    const y = 1 + Math.random() * 2;
    
    sprite.position.set(
        Math.cos(angle) * dist * (Math.random()>0.5?1:-1), // Left or right
        y,
        Math.sin(angle) * dist * -1 // In front (negative Z is forward usually, but camera is at +Z)
        // Wait, camera is at Z=8 looking at 0. So negative Z is behind chameleon? 
        // Chameleon is at 0. Camera at +8. 
        // We want bugs between Camera and Chameleon? Or behind Chameleon?
        // Let's put bugs at Z = 2 to 4 (between cam and cham)
    );
    sprite.position.z = 2 + Math.random() * 2;

    sprite.userData = { 
        char: char, 
        baseY: sprite.position.y, 
        offset: Math.random() * 100,
        speed: 0.5 + Math.random() * 0.5
    };
    
    scene.add(sprite);
    STATE.bugs.push(sprite);
    return sprite;
}

function spawnBugsForLevel() {
    STATE.bugs.forEach(b => scene.remove(b));
    STATE.bugs = [];
    
    const lvl = LEVELS[STATE.levelIdx];
    const pool = lvl.keys.split('');
    
    // Create UI Keyboard
    const kb = document.getElementById('keyboard-hud');
    kb.innerHTML = '';
    pool.forEach(k => {
        const div = document.createElement('div');
        div.className = 'key-box';
        div.id = `ui-key-${k}`;
        div.textContent = k.toUpperCase();
        kb.appendChild(div);
    });

    // Spawn 3-5 bugs at a time
    for(let i=0; i<3; i++) {
        createBug(pool[Math.floor(Math.random()*pool.length)]);
    }
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    STATE.isPlaying = true;
    STATE.score = 0;
    STATE.levelIdx = 0;
    document.getElementById('score-el').textContent = "‚≠ê 0";
    spawnBugsForLevel();
}

function shootTongue(targetSprite) {
    if(tongueActive) return; // Busy
    tongueActive = true;
    playSlurp();

    // 1. Calculate Target local position relative to head
    // We need to convert sprite world pos to head local space
    // For simplicity in this tween, we will just stretch the tongue mesh to the distance
    
    const startPos = new THREE.Vector3();
    tongueMesh.getWorldPosition(startPos); // Tip of mouth
    const dist = startPos.distanceTo(targetSprite.position);

    // Look at target with head (already happening in update)
    // Point tongue at target
    tongueMesh.lookAt(targetSprite.position);
    
    // Animate Scale Z (stretch)
    let s = 0;
    const speed = 0.15; // seconds
    
    // Animation Loop for Tongue
    const startTime = clock.getElapsedTime();
    
    function animTongue() {
        const now = clock.getElapsedTime();
        const t = (now - startTime) / speed; // 0 to 1
        
        if(t < 0.5) {
            // Out
            tongueMesh.visible = true;
            tongueMesh.scale.z = dist * (t * 2); 
            requestAnimationFrame(animTongue);
        } else if (t < 1.0) {
            // In (Bring bug back)
            if(targetSprite.parent) {
                targetSprite.position.lerp(startPos, 0.2); // Drag bug
                targetSprite.scale.multiplyScalar(0.8); // Shrink bug
            }
            tongueMesh.scale.z = dist * (1 - (t-0.5)*2);
            requestAnimationFrame(animTongue);
        } else {
            // Done
            tongueMesh.visible = false;
            tongueActive = false;
            
            // Eat Effect
            scene.remove(targetSprite);
            STATE.bugs = STATE.bugs.filter(b => b !== targetSprite);
            
            // Feedback
            createParticles(startPos, 0xffeb3b);
            jaw.rotation.x = 0; // Close mouth
            
            // Spawn replacement
            const lvl = LEVELS[STATE.levelIdx];
            createBug(lvl.keys[Math.floor(Math.random()*lvl.keys.length)]);
            
            // Score
            STATE.score += 10;
            document.getElementById('score-el').textContent = "‚≠ê " + STATE.score;
            
            // Level Check
            if(STATE.score > (STATE.levelIdx+1) * 100) {
                levelComplete();
            }
        }
    }
    
    // Open Mouth
    jaw.rotation.x = 0.5;
    animTongue();
}

document.addEventListener('keydown', (e) => {
    if(!STATE.isPlaying || tongueActive) return;
    const k = e.key.toLowerCase();
    
    // UI Feedback
    const uiKey = document.getElementById(`ui-key-${k}`);
    if(uiKey) {
        uiKey.classList.add('active');
        setTimeout(()=>uiKey.classList.remove('active'), 150);
    }

    // Find Bug
    const target = STATE.bugs.find(b => b.userData.char === k);
    
    if(target) {
        // Success
        shootTongue(target);
        
        // Popup Text
        const div = document.createElement('div');
        div.className = 'pop-text';
        div.textContent = k.toUpperCase();
        div.style.left = (window.innerWidth/2 + (Math.random()-0.5)*100) + 'px';
        div.style.top = (window.innerHeight/2 - 100) + 'px';
        document.body.appendChild(div);
        setTimeout(()=>div.remove(), 1000);
        
    } else {
        // Wrong key sound?
        // synth.triggerAttackRelease("C2", "16n");
    }
});

function createParticles(pos, color) {
    const geo = new THREE.BufferGeometry();
    const count = 10;
    const posArray = [];
    for(let i=0; i<count*3; i++) posArray.push((Math.random()-0.5));
    geo.setAttribute('position', new THREE.Float32BufferAttribute(posArray, 3));
    const mat = new THREE.PointsMaterial({ color: color, size: 0.2 });
    const pts = new THREE.Points(geo, mat);
    pts.position.copy(pos);
    scene.add(pts);
    setTimeout(()=>scene.remove(pts), 500);
}

function levelComplete() {
    STATE.isPlaying = false;
    playWin();
    
    // Poop sequence
    setTimeout(() => {
        playPoop();
        const poop = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5), new THREE.MeshStandardMaterial({color:0x8B4513}));
        poop.position.set(0, -1, -2);
        scene.add(poop);
        
        // Show screen
        setTimeout(() => {
            document.getElementById('end-screen').classList.remove('hidden');
        }, 1000);
    }, 1000);
}

/**
 * ANIMATION LOOP
 */
function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // 1. Animate Bugs (Bobbing)
    if(STATE.bugs.length > 0) {
        // Find closest bug to look at
        // We'll just look at the first one in array for simplicity, or nearest
        STATE.activeBug = STATE.bugs[0]; 
        
        STATE.bugs.forEach((b, i) => {
            b.position.y = b.userData.baseY + Math.sin(time * 2 + b.userData.offset) * 0.5;
            // Slowly wander
            b.position.x += Math.sin(time + i) * 0.01;
        });
        
        targetLookAt.copy(STATE.activeBug.position);
    } else {
        // Idle look
        targetLookAt.set(Math.sin(time)*2, 1, 5);
    }

    // 2. Character IK (Look at target)
    // Smoothly interpolate head rotation
    const dummy = new THREE.Object3D();
    dummy.position.copy(headGroup.position);
    dummy.lookAt(targetLookAt);
    headGroup.quaternion.slerp(dummy.quaternion, 0.1);

    // Eyes follow strictly
    eyeL.lookAt(targetLookAt);
    eyeR.lookAt(targetLookAt);

    // 3. Idle Breathing
    chameleonGroup.position.y = Math.sin(time * 2) * 0.05;
    chameleonGroup.scale.setScalar(1 + Math.sin(time * 4) * 0.005);

    renderer.render(scene, camera);
}

// Button Events
document.getElementById('btn-start').addEventListener('click', () => {
    initAudio().then(startGame);
});
document.getElementById('btn-next').addEventListener('click', () => {
    document.getElementById('end-screen').classList.add('hidden');
    STATE.levelIdx = (STATE.levelIdx + 1) % LEVELS.length;
    startGame();
});

// Init
initThree();

</script>
</body>
</html>
